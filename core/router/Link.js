/* Link.svelte generated by Svelte v3.31.2 */
import {
  SvelteComponentDev,
  add_location,
  assign,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_spread_update,
  init,
  insert_dev,
  listen_dev,
  safe_not_equal,
  set_attributes,
  transition_in,
  transition_out,
  update_slot,
  validate_slots,
  validate_store,
} from "https://cdn.skypack.dev/svelte@3.31.2/internal";

import {
  getContext,
  createEventDispatcher,
} from "https://cdn.skypack.dev/svelte@3.31.2/";

import { ROUTER, LOCATION } from "./contexts.js";
import { navigate } from "./history.js";
import { startsWith, resolve, shouldNavigate } from "./utils.js";
const file = "Link.svelte";

function create_fragment(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = /*#slots*/ ctx[16].default;
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/ ctx[15],
    null
  );

  let a_levels = [
    { href: /*href*/ ctx[0] },
    { "aria-current": /*ariaCurrent*/ ctx[2] },
    /*props*/ ctx[1],
    /*$$restProps*/ ctx[6],
  ];

  let a_data = {};

  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }

  const block = {
    c: function create() {
      a = element("a");
      if (default_slot) default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file, 40, 0, 1186);
    },
    l: function claim(nodes) {
      throw new Error(
        "options.hydrate only works if the component was compiled with the `hydratable: true` option"
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);

      if (default_slot) {
        default_slot.m(a, null);
      }

      current = true;

      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*onClick*/ ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx, [dirty]) {
      if (default_slot) {
        if (default_slot.p && dirty & /*$$scope*/ 32768) {
          update_slot(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/ ctx[15],
            dirty,
            null,
            null
          );
        }
      }

      set_attributes(
        a,
        (a_data = get_spread_update(a_levels, [
          (!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
          (!current || dirty & /*ariaCurrent*/ 4) && {
            "aria-current": /*ariaCurrent*/ ctx[2],
          },
          dirty & /*props*/ 2 && /*props*/ ctx[1],
          dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
        ]))
      );
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(a);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    },
  };

  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx,
  });

  return block;
}

function instance($$self, $$props, $$invalidate) {
  let ariaCurrent;
  const omit_props_names = ["to", "replace", "state", "getProps"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $base;
  let $location;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let { to = "#" } = $$props;
  let { replace = false } = $$props;
  let { state = {} } = $$props;
  let { getProps = () => ({}) } = $$props;
  const { base } = getContext(ROUTER);
  validate_store(base, "base");
  component_subscribe($$self, base, (value) =>
    $$invalidate(13, ($base = value))
  );
  const location = getContext(LOCATION);
  validate_store(location, "location");
  component_subscribe($$self, location, (value) =>
    $$invalidate(14, ($location = value))
  );
  const dispatch = createEventDispatcher();
  let href, isPartiallyCurrent, isCurrent, props;

  function onClick(event) {
    dispatch("click", event);

    if (shouldNavigate(event)) {
      event.preventDefault();

      // Don't push another entry to the history stack when the user
      // clicks on a Link to the page they are currently on.
      const shouldReplace = $location.pathname === href || replace;

      navigate(href, { state, replace: shouldReplace });
    }
  }

  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(
      6,
      ($$restProps = compute_rest_props($$props, omit_props_names))
    );
    if ("to" in $$new_props) $$invalidate(7, (to = $$new_props.to));
    if ("replace" in $$new_props)
      $$invalidate(8, (replace = $$new_props.replace));
    if ("state" in $$new_props) $$invalidate(9, (state = $$new_props.state));
    if ("getProps" in $$new_props)
      $$invalidate(10, (getProps = $$new_props.getProps));
    if ("$$scope" in $$new_props)
      $$invalidate(15, ($$scope = $$new_props.$$scope));
  };

  $$self.$capture_state = () => ({
    getContext,
    createEventDispatcher,
    ROUTER,
    LOCATION,
    navigate,
    startsWith,
    resolve,
    shouldNavigate,
    to,
    replace,
    state,
    getProps,
    base,
    location,
    dispatch,
    href,
    isPartiallyCurrent,
    isCurrent,
    props,
    onClick,
    $base,
    $location,
    ariaCurrent,
  });

  $$self.$inject_state = ($$new_props) => {
    if ("to" in $$props) $$invalidate(7, (to = $$new_props.to));
    if ("replace" in $$props) $$invalidate(8, (replace = $$new_props.replace));
    if ("state" in $$props) $$invalidate(9, (state = $$new_props.state));
    if ("getProps" in $$props)
      $$invalidate(10, (getProps = $$new_props.getProps));
    if ("href" in $$props) $$invalidate(0, (href = $$new_props.href));
    if ("isPartiallyCurrent" in $$props)
      $$invalidate(11, (isPartiallyCurrent = $$new_props.isPartiallyCurrent));
    if ("isCurrent" in $$props)
      $$invalidate(12, (isCurrent = $$new_props.isCurrent));
    if ("props" in $$props) $$invalidate(1, (props = $$new_props.props));
    if ("ariaCurrent" in $$props)
      $$invalidate(2, (ariaCurrent = $$new_props.ariaCurrent));
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*to, $base*/ 8320) {
      $: $$invalidate(
        0,
        (href = to === "/" ? $base.uri : resolve(to, $base.uri))
      );
    }

    if ($$self.$$.dirty & /*$location, href*/ 16385) {
      $: $$invalidate(
        11,
        (isPartiallyCurrent = startsWith($location.pathname, href))
      );
    }

    if ($$self.$$.dirty & /*href, $location*/ 16385) {
      $: $$invalidate(12, (isCurrent = href === $location.pathname));
    }

    if ($$self.$$.dirty & /*isCurrent*/ 4096) {
      $: $$invalidate(2, (ariaCurrent = isCurrent ? "page" : undefined));
    }

    if (
      $$self.$$.dirty &
      /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 23553
    ) {
      $: $$invalidate(
        1,
        (props = getProps({
          location: $location,
          href,
          isPartiallyCurrent,
          isCurrent,
        }))
      );
    }
  };

  return [
    href,
    props,
    ariaCurrent,
    base,
    location,
    onClick,
    $$restProps,
    to,
    replace,
    state,
    getProps,
    isPartiallyCurrent,
    isCurrent,
    $base,
    $location,
    $$scope,
    slots,
  ];
}

class Link extends SvelteComponentDev {
  constructor(options) {
    super(options);

    init(this, options, instance, create_fragment, safe_not_equal, {
      to: 7,
      replace: 8,
      state: 9,
      getProps: 10,
    });

    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment.name,
    });
  }

  get to() {
    throw new Error(
      "<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set to(value) {
    throw new Error(
      "<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  get replace() {
    throw new Error(
      "<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set replace(value) {
    throw new Error(
      "<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  get state() {
    throw new Error(
      "<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set state(value) {
    throw new Error(
      "<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  get getProps() {
    throw new Error(
      "<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set getProps(value) {
    throw new Error(
      "<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }
}

export default Link;
