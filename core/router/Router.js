/* Router.svelte generated by Svelte v3.31.2 */
import {
  SvelteComponentDev,
  component_subscribe,
  create_slot,
  dispatch_dev,
  init,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot,
  validate_slots,
  validate_store,
} from "https://cdn.skypack.dev/svelte@3.31.2/internal";

import {
  getContext,
  setContext,
  onMount,
} from "https://cdn.skypack.dev/svelte@3.31.2/";

import { writable, derived } from "https://cdn.skypack.dev/svelte@3.31.2/store";
import { LOCATION, ROUTER } from "./contexts.js";
import { globalHistory } from "./history.js";
import { pick, match, stripSlashes, combinePaths } from "./utils.js";
const file = "Router.svelte";

function create_fragment(ctx) {
  let current;
  const default_slot_template = /*#slots*/ ctx[9].default;
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/ ctx[8],
    null
  );

  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error(
        "options.hydrate only works if the component was compiled with the `hydratable: true` option"
      );
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }

      current = true;
    },
    p: function update(ctx, [dirty]) {
      if (default_slot) {
        if (default_slot.p && dirty & /*$$scope*/ 256) {
          update_slot(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/ ctx[8],
            dirty,
            null,
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    },
  };

  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx,
  });

  return block;
}

function instance($$self, $$props, $$invalidate) {
  let $base;
  let $location;
  let $routes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, ["default"]);
  let { basepath = "/" } = $$props;
  let { url = null } = $$props;
  const locationContext = getContext(LOCATION);
  const routerContext = getContext(ROUTER);
  const routes = writable([]);
  validate_store(routes, "routes");
  component_subscribe($$self, routes, (value) =>
    $$invalidate(7, ($routes = value))
  );
  const activeRoute = writable(null);
  let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

  // If locationContext is not set, this is the topmost Router in the tree.
  // If the `url` prop is given we force the location to it.
  const location =
    locationContext ||
    writable(url ? { pathname: url } : globalHistory.location);

  validate_store(location, "location");
  component_subscribe($$self, location, (value) =>
    $$invalidate(6, ($location = value))
  );

  // If routerContext is set, the routerBase of the parent Router
  // will be the base for this Router's descendants.
  // If routerContext is not set, the path and resolved uri will both
  // have the value of the basepath prop.
  const base = routerContext
    ? routerContext.routerBase
    : writable({ path: basepath, uri: basepath });

  validate_store(base, "base");
  component_subscribe($$self, base, (value) =>
    $$invalidate(5, ($base = value))
  );

  const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    // If there is no activeRoute, the routerBase will be identical to the base.
    if (activeRoute === null) {
      return base;
    }

    const { path: basepath } = base;
    const { route, uri } = activeRoute;

    // Remove the potential /* or /*splatname from
    // the end of the child Routes relative paths.
    const path = route.default ? basepath : route.path.replace(/\*.*$/, "");

    return { path, uri };
  });

  function registerRoute(route) {
    const { path: basepath } = $base;
    let { path } = route;

    // We store the original path in the _path property so we can reuse
    // it when the basepath changes. The only thing that matters is that
    // the route reference is intact, so mutation is fine.
    route._path = path;

    route.path = combinePaths(basepath, path);

    if (typeof window === "undefined") {
      // In SSR we should set the activeRoute immediately if it is a match.
      // If there are more Routes being registered after a match is found,
      // we just skip them.
      if (hasActiveRoute) {
        return;
      }

      const matchingRoute = match(route, $location.pathname);

      if (matchingRoute) {
        activeRoute.set(matchingRoute);
        hasActiveRoute = true;
      }
    } else {
      routes.update((rs) => {
        rs.push(route);
        return rs;
      });
    }
  }

  function unregisterRoute(route) {
    routes.update((rs) => {
      const index = rs.indexOf(route);
      rs.splice(index, 1);
      return rs;
    });
  }

  if (!locationContext) {
    // The topmost Router in the tree is responsible for updating
    // the location store and supplying it through context.
    onMount(() => {
      const unlisten = globalHistory.listen((history) => {
        location.set(history.location);
      });

      return unlisten;
    });

    setContext(LOCATION, location);
  }

  setContext(ROUTER, {
    activeRoute,
    base,
    routerBase,
    registerRoute,
    unregisterRoute,
  });

  const writable_props = ["basepath", "url"];

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });

  $$self.$$set = ($$props) => {
    if ("basepath" in $$props) $$invalidate(3, (basepath = $$props.basepath));
    if ("url" in $$props) $$invalidate(4, (url = $$props.url));
    if ("$$scope" in $$props) $$invalidate(8, ($$scope = $$props.$$scope));
  };

  $$self.$capture_state = () => ({
    getContext,
    setContext,
    onMount,
    writable,
    derived,
    LOCATION,
    ROUTER,
    globalHistory,
    pick,
    match,
    stripSlashes,
    combinePaths,
    basepath,
    url,
    locationContext,
    routerContext,
    routes,
    activeRoute,
    hasActiveRoute,
    location,
    base,
    routerBase,
    registerRoute,
    unregisterRoute,
    $base,
    $location,
    $routes,
  });

  $$self.$inject_state = ($$props) => {
    if ("basepath" in $$props) $$invalidate(3, (basepath = $$props.basepath));
    if ("url" in $$props) $$invalidate(4, (url = $$props.url));
    if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$base*/ 32) {
      // This reactive statement will update all the Routes' path when
      // the basepath changes.
      $: {
        const { path: basepath } = $base;

        routes.update((rs) => {
          rs.forEach((r) => (r.path = combinePaths(basepath, r._path)));
          return rs;
        });
      }
    }

    if ($$self.$$.dirty & /*$routes, $location*/ 192) {
      // This reactive statement will be run when the Router is created
      // when there are no Routes and then again the following tick, so it
      // will not find an active Route in SSR and in the browser it will only
      // pick an active Route after all Routes have been registered.
      $: {
        const bestMatch = pick($routes, $location.pathname);
        activeRoute.set(bestMatch);
      }
    }
  };

  return [
    routes,
    location,
    base,
    basepath,
    url,
    $base,
    $location,
    $routes,
    $$scope,
    slots,
  ];
}

class Router extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      basepath: 3,
      url: 4,
    });

    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router",
      options,
      id: create_fragment.name,
    });
  }

  get basepath() {
    throw new Error(
      "<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set basepath(value) {
    throw new Error(
      "<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  get url() {
    throw new Error(
      "<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }

  set url(value) {
    throw new Error(
      "<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    );
  }
}

export default Router;
